package me.maddinoriginal.newkitpvp.data;

import me.maddinoriginal.newkitpvp.configuration.PlayerdataConfig;
import me.maddinoriginal.newkitpvp.kits.KitCategory;
import me.maddinoriginal.newkitpvp.kits.KitType;
import me.maddinoriginal.newkitpvp.utils.Achievement;
import org.bukkit.configuration.file.FileConfiguration;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

public class PlayerData {

    /**
     * Used to store all the stats of a player, like kills and coins
     * is part of the KitPlayer class and gets generated by it via its constructor
     * the KitPlayer class kind of manages its playerdata via the methods within this class
     */

    private final UUID UUID;
    private final String NAME;
    private FileConfiguration config;
    private String path;
    private String subpathKits;
    private String subpathAchievements;

    private Stat kills = new Stat();
    private Stat deaths = new Stat();
    private Stat assists = new Stat();
    private Stat coins = new Stat();
    private Stat tokens = new Stat();

    private ArrayList<KitType> unlockedKits = new ArrayList<>();
    private ArrayList<Achievement> achievements = new ArrayList<>();

    public PlayerData(UUID uuid, String playerName) {
        this.UUID = uuid;
        this.NAME = playerName;
        this.config = PlayerdataConfig.get();
        this.path = uuid.toString() + ".";
        this.subpathKits = path + "unlocked-kits.";
        this.subpathAchievements = path + "achievements.";
        check();
        load();
    }

    //Pr√ºft, dass alle Werte gesetzt sind und fehlende Werte werden neu gesetzt
    private void check() {
        config.set(path + "name", NAME);

        List<String> subpaths = Arrays.asList("kills", "deaths", "assists", "coins", "tokens");

        for (String subpath : subpaths) {
            if (!config.contains(path + subpath)) {
                config.set(path + subpath, 0);
            }
        }

        for (KitType kit : KitType.values()) {
            if (!config.contains(subpathKits + kit.name().toLowerCase())) {
                if (kit.getKit() != null && kit.getKit().getCategory() != null) {
                    if (kit.getKit().getCategory() != KitCategory.STANDARD) {
                        config.set(subpathKits + kit.name().toLowerCase(), false);
                    }
                }
            }
        }
        for (Achievement achievement : Achievement.values()) {
            if (!config.contains(subpathAchievements + achievement.name().toLowerCase())) {
                config.set(subpathAchievements + achievement.name().toLowerCase(), false);
            }
        }
        PlayerdataConfig.save();
    }

    private void load() {
        kills.setAmount(config.getInt(path + "kills"));
        deaths.setAmount(config.getInt(path + "deaths"));
        assists.setAmount(config.getInt(path + "assists"));
        coins.setAmount(config.getInt(path + "coins"));
        tokens.setAmount(config.getInt(path + "tokens"));

        for (KitType kit : KitType.values()) {
            if (kit.getKit() != null && kit.getKit().getCategory() != null) {
                if (kit.getKit().getCategory() != KitCategory.STANDARD) {
                    if (config.getBoolean(subpathKits + kit.name().toLowerCase())) {
                        unlockedKits.add(kit);
                    }
                }
            }
        }
        for (Achievement achievement : Achievement.values()) {
            if (config.getBoolean(subpathAchievements + achievement.name().toLowerCase())) {
                achievements.add(achievement);
            }
        }
    }

    public void save() {
        config.set(path + "kills", kills.getAmount());
        config.set(path + "deaths", deaths.getAmount());
        config.set(path + "assists", assists.getAmount());
        config.set(path + "coins", coins.getAmount());
        config.set(path + "tokens", tokens.getAmount());
        for (KitType kit : unlockedKits) {
            config.set(subpathKits + kit.name().toLowerCase(), true);
        }
        for (Achievement achievement : achievements) {
            config.set(subpathAchievements + achievement.name().toLowerCase(), true);
        }
        PlayerdataConfig.save();
    }

    public UUID getUUID() {
        return UUID;
    }

    public String getName() {
        return NAME;
    }

    public Stat getKills() {
        return kills;
    }

    public Stat getDeaths() {
        return deaths;
    }

    public Stat getAssists() {
        return assists;
    }

    public Stat getCoins() {
        return coins;
    }

    public Stat getTokens() {
        return tokens;
    }

    public boolean hasKitUnlocked(KitType kitType) {
        if (unlockedKits.contains(kitType)) {
            return true;
        }
        return false;
    }

    public void unlockKit(KitType kitType) {
        if (!hasKitUnlocked(kitType)) {
            unlockedKits.add(kitType);
        }
    }

    public boolean hasAchievementUnlocked(Achievement achievement) {
        if (achievements.contains(achievement)) {
            return true;
        }
        return false;
    }

    public void unlockAchievement(Achievement achievement) {
        if (!hasAchievementUnlocked(achievement)) {
            achievements.add(achievement);
        }
    }
}
